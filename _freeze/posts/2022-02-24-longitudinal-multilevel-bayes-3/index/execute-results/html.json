{
  "hash": "2b158e7ea4a6c3c6f2d27aa69a4703b4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Bayesian analysis of longitudinal multilevel data using brms and rethinking - part 3  \ndescription: Part 3 of a tutorial showing how to fit Bayesian models using the `brms` package.\nauthor: Andreas Handel\ndate: '2022-02-24'\nlastMod: \"2022-04-18\"\naliases:\n  - ../longitudinal-multilevel-bayesian-analysis-3/\ncategories: \n- R\n- Data Analysis\n- Bayesian\nimage: \"featured.png\"\n---\n\n\n\n\n\n\n\n\nThis is part 3 of a tutorial illustrating how one can use the `brms` and `rethinking` R packages to perform a Bayesian analysis of longitudinal data using a multilevel/hierarchical/mixed-effects setup.\n\nI assume you've read both [part 1](/posts/longitudinal-multilevel-bayesian-analysis-1/), and [part 2](/posts/longitudinal-multilevel-bayesian-analysis-2/) otherwise this post won't make much sense.\n\n\n# Introduction\n\nIn the previous post, I showed how to fit the data using the `rethinking` package. Now I'm re-doing it using `brms`. The [`brms` package](https://paul-buerkner.github.io/brms/) is a widely used and very powerful tool to interface with Stan. It has overall more capabilities compared to `rethinking`. It tends to also be more robustly developed and maintained.\n\nIn my opinion, the main disadvantage is that it is often not obvious how to go from mathematical model to code, unless one has a good bit of experience jumping between the often terse formula notation of `brms` and the model equations. I'm not there yet, so I currently prefer to start with `rethinking`. But since `brms` can do things that are not as easy (or impossible) with `rethinking`, it seems good to know how to use both.\n\nAlso, comparing results using two different numerical packages is always good (even though both use `Stan` underneath, so in some sense those are not truly independent software routines).\n\nAs was true for `ulam/rethinking`, fitting the models can take a good bit of time. I therefore wrote separate `R` scripts for the fitting and the exploring parts. The code chunks from those scripts are shown below. The manual effort and slower pace of copying and pasting the code chunks from this tutorial and re-produce them can help in learning, but if you just want to get all the code from this post you can find it [here](brmsfitmodels.R) and [here](brmsexploremodels.R).\n\n\n\n# R Setup\n\nAs always, make sure these packages are installed. `brms` uses the [Stan Bayesian modeling engine](https://mc-stan.org/). If you did the fitting with `rethinking` tutorial, you'll have it already installed, otherwise you'll need to install it. It is in my experience mostly seamless, but at times it seems to be tricky. I generally follow the instructions on the [`rethinking` website](https://github.com/rmcelreath/rethinking) and it has so far always worked for me. It might need some fiddling, but you should be able to get them all to work.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary('dplyr') # for data manipulation\nlibrary('ggplot2') # for plotting\nlibrary('cmdstanr') #for model fitting\nlibrary('brms') # for model fitting\nlibrary('posterior') #for post-processing\nlibrary('fs') #for file path\n```\n:::\n\n\n\n\n\n# Data loading\n\nWe'll jump right in and load the data we generated in the previous tutorial.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimdat <- readRDS(\"simdat.Rds\")\n#pulling out number of observations\nNtot = length(unique(simdat$m3$id))\n\n#fitting dataset 3\n#we need to make sure the id is coded as a factor variable\n#also removing anything in the dataframe that's not used for fitting\n#makes the Stan code more robust\nfitdat=list(id = as.factor(simdat[[3]]$id),\n            outcome = simdat[[3]]$outcome,\n            dose_adj = simdat[[3]]$dose_adj,\n            time = simdat[[3]]$time)\n```\n:::\n\n\n\n\n# Fitting with `brms`\n\nWe'll fit some of the models we discussed in parts 1 and 2, now using the `brms` package. The main function in that package, which does the fitting using Stan, is `brm`. \n\nFirst, we'll specify each model. We'll do that first, then run them all in a single loop. \nSince we determined when using `ulam`/`rethinking` that our model 2 was a bad model, and model 4 and 4a didn't lead to much of a difference, I'm skipping those here and only do models 1, 2a, 3 and 4. I'm also skipping model 5 since I only ran that for diagnostics/understanding and it doesn't encode the right structure, since dose effect is missing.\n\n\n## Model 1\n\nThis is one of the models with individual-level and dose-level effects, all priors fixed. This model has $2N+2+1$ parameters. $N$ each for the individual-level intercepts for $\\alpha$ and $\\beta$ (the $a_{0,i}$ and $b_{0,i}$ parameters), the two dose-level parameters $a_1$ and $b_1$, and 1 overall deviation, $\\sigma$ for the outcome distribution. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#no-pooling model\n#separate intercept for each individual/id\n#2x(N+1)+1 parameters\nm1eqs <- bf(  #main equation for time-series trajectory\n          outcome ~  exp(alpha)*log(time) - exp(beta)*time,\n          #equations for alpha and beta\n          alpha ~ 0 + id + dose_adj,\n          beta  ~ 0 + id + dose_adj,\n          nl = TRUE)\n\nm1priors <- c(#assign priors to all coefficients related to both id and dose_adj for alpha and beta\n              prior(normal(2, 10),  class = \"b\",  nlpar = \"alpha\"),\n              prior(normal(0.5, 10),  class = \"b\",  nlpar = \"beta\"),\n              #change the dose_adj priors to something different than the id priors\n              prior(normal(0.3, 1),   class = \"b\",  nlpar = \"alpha\", coef = \"dose_adj\"),\n              prior(normal(-0.3, 1),  class = \"b\",  nlpar = \"beta\", coef = \"dose_adj\"),\n              prior(cauchy(0,1), class = \"sigma\") )\n```\n:::\n\n\n\n\nNotice how this notation in `brms` looks quite a bit different from the mathematical equations or the `ulam` implementation. That's a part I don't particularly like about `brms`, the very condensed formula notation. It takes time getting used to and it always requires extra checking to ensure the model implemented in code corresponds to the mathematical model. One can check by looking at the priors and make sure they look as expected. We'll do that below after we fit.\n\n## Model 2a \n\nThis is the easiest model, with only population level effects for intercept and dose, so only 2+2+1 parameters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#full-pooling model\n#2+2+1 parameters\nm2aeqs <- bf(  #main equation for time-series trajectory\n  outcome ~ exp(alpha)*log(time) - exp(beta)*time,\n  #equations for alpha and beta\n  alpha ~ 1 + dose_adj,\n  beta  ~  1 + dose_adj,\n  nl = TRUE)\n\nm2apriors <- c(prior(normal(2, 2),  class = \"b\",  nlpar = \"alpha\", coef = \"Intercept\"),\n              prior(normal(0.5, 2),  class = \"b\",  nlpar = \"beta\", coef = \"Intercept\"),\n              prior(normal(0.3, 1),   class = \"b\",  nlpar = \"alpha\", coef = \"dose_adj\"),\n              prior(normal(-0.3, 1),  class = \"b\",  nlpar = \"beta\", coef = \"dose_adj\"),\n              prior(cauchy(0,1), class = \"sigma\")  )\n```\n:::\n\n\n\n\n## Model 3\n\nThis is the same as model 1 but with different values for the priors.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#same as model 1 but regularizing priors\nm3eqs <- m1eqs\n\nm3priors <- c(#assign priors to all coefficients related to id and dose_adj for alpha and beta\n  prior(normal(2, 1),  class = \"b\",  nlpar = \"alpha\"),\n  prior(normal(0.5, 1),  class = \"b\",  nlpar = \"beta\"),\n  #change the dose_adj priors to something different than the id priors\n  prior(normal(0.3, 1),   class = \"b\",  nlpar = \"alpha\", coef = \"dose_adj\"),\n  prior(normal(-0.3, 1),  class = \"b\",  nlpar = \"beta\", coef = \"dose_adj\"),\n  prior(cauchy(0,1), class = \"sigma\") )\n```\n:::\n\n\n\n\n## Model 4\n\nThis is the adaptive-pooling multi-level model where priors are estimated.\nHere we have for each main parameter ($\\alpha$ and $\\beta$) an overall mean and standard deviation, and N individual intercepts, so 2 times 1+1+N. And of course we still have the 2 dose-related parameters and the overall standard deviation, so a total of 2*(1+1+N)+2+1 parameters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#adaptive prior, partial-pooling model\nm4eqs <- bf(  #main equation for time-series trajectory\n  outcome ~ exp(alpha)*log(time) - exp(beta)*time,\n  #equations for alpha and beta\n  alpha ~  (1|id) + dose_adj,\n  beta  ~  (1|id) + dose_adj,\n  nl = TRUE)\n\nm4priors <- c(prior(normal(2, 1),  class = \"b\",  nlpar = \"alpha\", coef = \"Intercept\"),\n              prior(normal(0.5, 1),  class = \"b\",  nlpar = \"beta\", coef = \"Intercept\"),\n              prior(normal(0.3, 1),   class = \"b\",  nlpar = \"alpha\", coef = \"dose_adj\"),\n              prior(normal(-0.3, 1),  class = \"b\",  nlpar = \"beta\", coef = \"dose_adj\"),\n              prior(cauchy(0,1), class = \"sd\", nlpar = \"alpha\"),\n              prior(cauchy(0,1), class = \"sd\", nlpar = \"beta\"),\n              prior(cauchy(0,1), class = \"sigma\")  )\n```\n:::\n\n\n\n\n## Combine models\n\nTo make our lives easier below, we combine all models and priors into lists.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#stick all models into a list\nmodellist = list(m1=m1eqs,m2a=m2aeqs,m3=m3eqs,m4=m4eqs)\n#also make list for priors\npriorlist = list(m1priors=m1priors,m2apriors=m2apriors,m3priors=m3priors,m4priors=m4priors)\n# set up a list in which we'll store our results\nfl = vector(mode = \"list\", length = length(modellist))\n```\n:::\n\n\n\n\n\n## Fitting setup\n\nWe define some general values for the fitting. Since the starting values depend on number of chains, we need to do this setup first.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#general settings for fitting\n#you might want to adjust based on your computer\nwarmup = 6000\niter = warmup + floor(warmup/2)\nmax_td = 18 #tree depth\nadapt_delta = 0.9999\nchains = 5\ncores  = chains\nseed = 1234\n```\n:::\n\n\n\n\n## Setting starting values\n\nWe'll again set starting values, as we did for `ulam/rethinking`. \nNote that `brms` needs them in a somewhat different form, namely as list of lists for each model, one list for each chain.\n\nI set different values for each chain, so I can check that each chain ends up at the same posterior. This is inspired by [this post by Solomon Kurz](https://solomonkurz.netlify.app/blog/2021-06-05-don-t-forget-your-inits/), though I keep it simpler and just use the `jitter` function.\n\nNote that this approach not only jitters (adds noise/variation) between chains, but also between the individual-level parameters for each chain. That's fine for our purpose, it might even be beneficial.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Setting starting values\n#starting values for model 1\nstartm1 = list(a0 = rep(2,Ntot), b0 = rep(0.5,Ntot), a1 = 0.5 , b1 = -0.5, sigma = 1)\n#starting values for model 2a\nstartm2a = list(a0 = 2, b0 = 0.5, a1 = 0.5 , b1 = 0.5, sigma = 1)\n#starting values for model 3\nstartm3 = startm1\n#starting values for models 4\nstartm4 = list(mu_a = 2, sigma_a = 1, mu_b = 0, sigma_b = 1, a1 = 0.5 , b1 = -0.5, sigma = 1)\n#put different starting values in list\n#need to be in same order as models below\n#one list for each chain, thus a 3-leveled list structure\n#for each chain, we add jitter so they start at different values\nstartlist = list( rep(list(lapply(startm1,jitter,10)),chains),\n                  rep(list(lapply(startm2a,jitter,10)),chains),\n                  rep(list(lapply(startm3,jitter,10)),chains),\n                  rep(list(lapply(startm4,jitter,10)),chains)\n                  )\n```\n:::\n\n\n\n\n\n## Model fitting\n\nWe'll use the same strategy to loop though all models and fit them. \nThe fitting code looks very similar to the previous one for `rethinking/ulam`, only now the fitting is done calling the `brm` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fitting models\n#loop over all models and fit them using ulam\nfor (n in 1:length(modellist))\n{\n\n  cat('************** \\n')\n  cat('starting model', names(modellist[n]), '\\n')\n\n  tstart=proc.time(); #capture current time\n\n  fl[[n]]$fit <- brm(formula = modellist[[n]],\n                   data = fitdat,\n                   family = gaussian(),\n                   prior = priorlist[[n]],\n                   init = startlist[[n]],\n                   control=list(adapt_delta=adapt_delta, max_treedepth = max_td),\n                   sample_prior = TRUE,\n                   chains=chains, cores = cores,\n                   warmup = warmup, iter = iter,\n                   seed = seed,\n                   backend = \"cmdstanr\"\n  )# end brm statement\n\n  tend=proc.time(); #capture current time\n  tdiff=tend-tstart;\n  runtime_minutes=tdiff[[3]]/60;\n\n  cat('model fit took this many minutes:', runtime_minutes, '\\n')\n  cat('************** \\n')\n\n  #add some more things to the fit object\n  fl[[n]]$runtime = runtime_minutes\n  fl[[n]]$model = names(modellist)[n]\n}\n# saving the results so we can use them later\nfilepath = fs::path(\"C:\",\"Dropbox\",\"datafiles\",\"longitudinalbayes\",\"brmsfits\", ext=\"Rds\")\n#filepath = fs::path(\"D:\",\"Dropbox\",\"datafiles\",\"longitudinalbayes\",\"brmsfits\", ext=\"Rds\")\nsaveRDS(fl,filepath)\n```\n:::\n\n\n\nYou'll likely find that model 1 takes the longest, the other ones run faster. You can check the runtime for each model by looking at `fl[[n]]$runtime`. It's useful to first run with few iterations (100s instead of 1000s), make sure everything works in principle, then do a \"final\" long run with longer chains.\n\n\n# Explore model fits\n\nAs before, fits are in the list called `fl`. For each model the actual fit is in `fit`, the model name is in `model` and the run time is in `runtime`. Note that the code chunks below come from [this second R script](brmsexploremodels.R), thus some things are repeated (e.g., loading of simulated data).\n\nAs we did after fitting with `ulam/rethinking`, let's briefly inspect some of the models. I'm again only showing a few of those explorations to illustrate what I mean. For any real fitting, it is important to carefully look at all the output and make sure everything worked as expected and makes sense.\n\nI'm again focusing on the simple model 2a, which has no individual-level parameters, thus only a total of 5. \n\nWe are using various additional packages here to get plots and output that looks similar to what `rethinking` produces. I'm getting most of the code snippets from the [Statistical Rethinking using `brms` book](https://bookdown.org/content/4857/) by Solomon Kurz.\n\nNeed a few more packages for this part:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary('dplyr') # for data manipulation\nlibrary('tidyr') # for data manipulation\nlibrary('ggplot2') # for plotting\nlibrary('rstan') #for model fitting\nlibrary('cmdstanr') #for model fitting\nlibrary('brms') # for model fitting\nlibrary('posterior') #for post-processing\nlibrary('bayesplot') #for plots\nlibrary('fs') #for file path\n```\n:::\n\n\n\nLoading the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# loading list of previously saved fits.\n# useful if we don't want to re-fit\n# every time we want to explore the results.\n# since the file is too large for GitHub\n# it is stored in a local folder\n# adjust accordingly for your setup\nfilepath = fs::path(\"D:\",\"Dropbox\",\"datafiles\",\"longitudinalbayes\",\"brmsfits\", ext=\"Rds\")\nif (!file_exists(filepath))\n{\n  filepath = fs::path(\"C:\",\"Data\",\"Dropbox\",\"datafiles\",\"longitudinalbayes\",\"brmsfits\", ext=\"Rds\")\n}\n\n\nfl <- readRDS(filepath)\n# also load data file used for fitting\nsimdat <- readRDS(\"simdat.Rds\")\n#pull our the data set we used for fitting\n#if you fit a different one of the simulated datasets, change accordingly\nfitdat <- simdat$m3\n#contains parameters used for fitting\npars <- simdat$m3pars\n```\n:::\n\n\n\nThe summary output looks a bit different compared to `ulam`, but fairly similar.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Model 2a summary\n#saving a bit of typing below\nfit2 <- fl[[2]]$fit\nsummary(fit2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: outcome ~ exp(alpha) * log(time) - exp(beta) * time \n         alpha ~ 1 + dose_adj\n         beta ~ 1 + dose_adj\n   Data: fitdat (Number of observations: 264) \n  Draws: 5 chains, each with iter = 9000; warmup = 6000; thin = 1;\n         total post-warmup draws = 15000\n\nRegression Coefficients:\n                Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nalpha_Intercept     2.98      0.02     2.94     3.02 1.00     6244     6691\nalpha_dose_adj      0.10      0.01     0.08     0.12 1.00     6569     7301\nbeta_Intercept      0.99      0.02     0.95     1.03 1.00     6387     6724\nbeta_dose_adj      -0.10      0.01    -0.11    -0.08 1.00     6947     7786\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     6.88      0.30     6.32     7.49 1.00     8391     7850\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nHere is the default trace plot. Note that `brms` only plots the post-warmup iterations, and also shows the posterior distributions. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Model 2a trace plots\nplot(fit2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/traceplot-1.png){width=672}\n:::\n:::\n\n\n\nSince I want to see if the different initial conditions did something useful, I was trying to make a trace plot that shows warmup. Solomon Kurz has [an example using the `ggmcmc` package](https://bookdown.org/content/4857/markov-chain-monte-carlo.html#visualization.), but his code doesn't work for me, it always ignores the warmup. I used 6000 warmup samples and 3000 post-warmup samples for each chain. Currently, the figure only shows post-warmup.\n\nFor now, it's another trace plot using the `bayesplot` package - also which has an example of making the plot I want, but for some reason the `stanfit` object inside the `brms` output does not contain the warmups. So for now, what's shown doesn't actually include the warmups. Leaving this plot for now and moving on...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Another trace plot, using the bayesplot package\nposterior <- rstan::extract(fit2$fit, inc_warmup = TRUE, permuted = FALSE)\nbayesplot::mcmc_trace(posterior, n_warmup = 400, pars = variables(fit2)[c(1,2,3,4,5)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/traceplot-2-1.png){width=672}\n:::\n:::\n\n\n\nHere is a version of the trank plots. I'm pulling out the first 5 variables since the others are not that interesting for this plot, e.g., they contain prior samples. You can look at them if you want.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Model 2a trank plots with bayesplot\nbayesplot::mcmc_rank_overlay(fit2, pars = variables(fit2)[c(1,2,3,4,5)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/trankplot-1.png){width=672}\n:::\n:::\n\n\n\nAnother nice plot I saw was an autocorrelation plot. One wants little autocorrelation for parameters. This seems to be the case:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::mcmc_acf(fit2, pars = variables(fit2)[c(1,2,3,4,5)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/autocorrelationplot-1.png){width=672}\n:::\n:::\n\n\n\n\nAnd finally a pair plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Model 2a pair plot\n# Correlation between posterior samples of parameters\npairs(fit2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/pairplot-1.png){width=672}\n:::\n:::\n\n\n\n\nWhile the layout looks different - and I didn't bother to try and make things look exactly the same between `brms` and `rethinking` - the overall results are similar. That's encouraging.\n\nSome of the plots already showed posterior distributions, but let's look at those more carefully.\n\n\n\n\n\n## Models 1 and 3\n\nLet's explore those two models first. Recall that they are the same, apart from the prior definitions. As previously, the wider priors for model 1 make it less efficient. With the settings I used, run times were 417 minutes for model 1 versus 61 minutes for model 3. \n\nLet's see if the priors impact the results, i.e. the posterior distributions.\nWe can actually do that by looking briefly at the summaries for both fits.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#save some typing\nfit1 <- fl[[1]]$fit\nfit3 <- fl[[3]]$fit\nsummary(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: outcome ~ exp(alpha) * log(time) - exp(beta) * time \n         alpha ~ 0 + id + dose_adj\n         beta ~ 0 + id + dose_adj\n   Data: fitdat (Number of observations: 264) \n  Draws: 5 chains, each with iter = 9000; warmup = 6000; thin = 1;\n         total post-warmup draws = 15000\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nalpha_id1          3.50      1.67     0.26     6.80 1.00     2840     4734\nalpha_id2          3.46      1.67     0.21     6.75 1.00     2839     4794\nalpha_id3          3.26      1.67     0.02     6.56 1.00     2839     4760\nalpha_id4          3.19      1.67    -0.05     6.49 1.00     2841     4760\nalpha_id5          3.24      1.67    -0.01     6.53 1.00     2839     4760\nalpha_id6          3.33      1.67     0.08     6.62 1.00     2839     4760\nalpha_id7          3.28      1.67     0.03     6.58 1.00     2841     4796\nalpha_id8          2.98      0.02     2.95     3.01 1.00    17885    10342\nalpha_id9          2.91      0.02     2.88     2.94 1.00    17315    10942\nalpha_id10         2.98      0.02     2.95     3.01 1.00    17656    10966\nalpha_id11         2.94      0.02     2.91     2.97 1.00    18085    10133\nalpha_id12         2.84      0.02     2.81     2.88 1.00    17692    11631\nalpha_id13         2.97      0.02     2.94     3.00 1.00    18451    10345\nalpha_id14         3.09      0.01     3.06     3.12 1.00    18387    10003\nalpha_id15         2.95      0.02     2.91     2.98 1.00    17682    10963\nalpha_id16         2.77      1.67    -0.52     6.01 1.00     2839     4781\nalpha_id17         2.54      1.67    -0.76     5.79 1.00     2840     4750\nalpha_id18         2.73      1.67    -0.57     5.97 1.00     2839     4798\nalpha_id19         2.76      1.67    -0.53     6.01 1.00     2839     4820\nalpha_id20         2.73      1.67    -0.56     5.98 1.00     2840     4771\nalpha_id21         2.71      1.67    -0.59     5.96 1.00     2840     4751\nalpha_id22         2.66      1.67    -0.64     5.91 1.00     2839     4807\nalpha_id23         2.65      1.67    -0.64     5.90 1.00     2840     4764\nalpha_id24         2.59      1.67    -0.70     5.84 1.00     2838     4762\nalpha_dose_adj     0.22      0.73    -1.19     1.65 1.00     2839     4785\nbeta_id1           0.75      1.71    -2.66     4.10 1.00     2420     4179\nbeta_id2           0.65      1.71    -2.76     4.01 1.00     2420     4181\nbeta_id3           0.70      1.71    -2.72     4.04 1.00     2419     4158\nbeta_id4           0.71      1.71    -2.70     4.06 1.00     2419     4155\nbeta_id5           0.93      1.71    -2.48     4.28 1.00     2418     4167\nbeta_id6           0.68      1.71    -2.73     4.03 1.00     2419     4175\nbeta_id7           0.77      1.71    -2.64     4.13 1.00     2419     4155\nbeta_id8           1.01      0.01     0.99     1.04 1.00    16977    10323\nbeta_id9           0.91      0.02     0.88     0.94 1.00    17374    11382\nbeta_id10          0.98      0.01     0.96     1.01 1.00    18009    10155\nbeta_id11          1.15      0.01     1.13     1.18 1.00    18260    10293\nbeta_id12          1.05      0.01     1.02     1.07 1.00    17891    11580\nbeta_id13          1.01      0.01     0.98     1.04 1.00    18998    10824\nbeta_id14          0.95      0.01     0.92     0.98 1.00    18321    10396\nbeta_id15          0.79      0.02     0.75     0.82 1.00    17550    11046\nbeta_id16          1.36      1.71    -1.99     4.77 1.00     2418     4208\nbeta_id17          1.08      1.71    -2.27     4.49 1.00     2419     4159\nbeta_id18          1.36      1.71    -2.00     4.77 1.00     2421     4150\nbeta_id19          1.44      1.71    -1.92     4.85 1.00     2417     4173\nbeta_id20          1.09      1.71    -2.25     4.50 1.00     2420     4083\nbeta_id21          1.31      1.71    -2.04     4.73 1.00     2420     4118\nbeta_id22          1.24      1.71    -2.10     4.65 1.00     2421     4122\nbeta_id23          1.12      1.71    -2.23     4.53 1.00     2419     4157\nbeta_id24          1.09      1.71    -2.26     4.51 1.00     2419     4209\nbeta_dose_adj     -0.21      0.74    -1.69     1.24 1.00     2419     4163\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     1.06      0.05     0.97     1.17 1.00    16342    11307\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(fit3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: outcome ~ exp(alpha) * log(time) - exp(beta) * time \n         alpha ~ 0 + id + dose_adj\n         beta ~ 0 + id + dose_adj\n   Data: fitdat (Number of observations: 264) \n  Draws: 5 chains, each with iter = 9000; warmup = 6000; thin = 1;\n         total post-warmup draws = 15000\n\nRegression Coefficients:\n               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nalpha_id1          3.31      0.25     2.83     3.80 1.00     2443     4189\nalpha_id2          3.27      0.25     2.79     3.75 1.00     2418     4115\nalpha_id3          3.07      0.25     2.59     3.55 1.00     2447     4120\nalpha_id4          3.00      0.25     2.52     3.48 1.00     2433     4196\nalpha_id5          3.05      0.25     2.56     3.53 1.00     2437     4206\nalpha_id6          3.14      0.25     2.66     3.62 1.00     2465     4179\nalpha_id7          3.09      0.25     2.61     3.57 1.00     2438     4311\nalpha_id8          2.98      0.02     2.95     3.01 1.00    18493    10858\nalpha_id9          2.91      0.02     2.87     2.94 1.00    18973    11242\nalpha_id10         2.98      0.02     2.95     3.01 1.00    18479    10529\nalpha_id11         2.94      0.02     2.91     2.97 1.00    18804    10454\nalpha_id12         2.84      0.02     2.81     2.87 1.00    18873    11236\nalpha_id13         2.97      0.02     2.94     3.00 1.00    19043    11438\nalpha_id14         3.09      0.01     3.06     3.12 1.00    19247    10690\nalpha_id15         2.95      0.02     2.91     2.98 1.00    19114    12099\nalpha_id16         2.96      0.25     2.48     3.44 1.00     2432     4256\nalpha_id17         2.73      0.25     2.25     3.21 1.00     2418     4214\nalpha_id18         2.92      0.25     2.43     3.39 1.00     2433     4335\nalpha_id19         2.95      0.25     2.47     3.43 1.00     2438     4308\nalpha_id20         2.92      0.25     2.43     3.40 1.00     2427     4161\nalpha_id21         2.90      0.25     2.41     3.37 1.00     2418     4311\nalpha_id22         2.85      0.25     2.36     3.33 1.00     2439     4182\nalpha_id23         2.84      0.25     2.36     3.32 1.00     2431     4213\nalpha_id24         2.78      0.25     2.30     3.26 1.00     2438     4170\nalpha_dose_adj     0.14      0.11    -0.07     0.35 1.00     2426     4307\nbeta_id1           1.05      0.24     0.58     1.53 1.00     2953     5165\nbeta_id2           0.96      0.24     0.49     1.43 1.00     2937     5242\nbeta_id3           1.00      0.24     0.53     1.47 1.00     2944     5168\nbeta_id4           1.01      0.24     0.54     1.49 1.00     2937     5142\nbeta_id5           1.24      0.24     0.76     1.71 1.00     2939     5218\nbeta_id6           0.99      0.24     0.52     1.46 1.00     2946     5117\nbeta_id7           1.08      0.24     0.60     1.55 1.00     2941     5223\nbeta_id8           1.01      0.01     0.99     1.04 1.00    18029    10844\nbeta_id9           0.91      0.02     0.88     0.93 1.00    18953    11005\nbeta_id10          0.98      0.01     0.96     1.01 1.00    18500    10509\nbeta_id11          1.15      0.01     1.13     1.17 1.00    18599    10418\nbeta_id12          1.05      0.01     1.02     1.07 1.00    19002    10853\nbeta_id13          1.01      0.01     0.98     1.04 1.00    18714    11040\nbeta_id14          0.95      0.01     0.92     0.98 1.00    19168    10286\nbeta_id15          0.79      0.02     0.75     0.82 1.00    18771    11344\nbeta_id16          1.06      0.24     0.58     1.53 1.00     2943     5165\nbeta_id17          0.78      0.25     0.30     1.25 1.00     2941     5155\nbeta_id18          1.05      0.24     0.58     1.53 1.00     2939     5207\nbeta_id19          1.14      0.24     0.66     1.61 1.00     2951     5251\nbeta_id20          0.79      0.25     0.31     1.26 1.00     2962     5253\nbeta_id21          1.00      0.24     0.52     1.47 1.00     2944     5222\nbeta_id22          0.94      0.24     0.46     1.41 1.00     2951     5207\nbeta_id23          0.82      0.25     0.34     1.29 1.00     2943     5263\nbeta_id24          0.79      0.25     0.31     1.26 1.00     2957     5311\nbeta_dose_adj     -0.08      0.11    -0.29     0.13 1.00     2939     5258\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     1.06      0.05     0.97     1.17 1.00    15961    10880\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nNote the different naming of the parameters in `brms`. It's unfortunately not possible (as far as I know) to get the names match the mathematical model. The parameters that have `dose` in their names are the ones we called $a_1$ and $b_1$ in our models. The many `_id` parameters are our previous $a_0$ and $b_0$ parameters. Conceptually, the latter are on the individual level. But we don't have a nested/multi-level structure here, which seems to lead `brms` to consider every parameter on the same level, and thus labeling them all _population level_. \n\n\nNow, let's look at priors and posteriors somewhat more. First, we extract priors and posteriors. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#get priors and posteriors for models 1 and 3\nm1prior <- prior_draws(fit1)\nm1post <- as_draws_df(fit1)\nm3prior <- prior_draws(fit3)\nm3post <- as_draws_df(fit3)\n```\n:::\n\n\n\nNow we can plot the distributions. I'm focusing on the $a_1$ and $b_1$ parameters since those are of more interest, and because I couldn't figure out quickly how to get out and process all the individual level $a_0$ and $b_0$ parameters from `brms` ðŸ˜.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#showing density plots for a1\n\n#make a data frame and get it in shape for ggplot\na1df <- data.frame(m1_prior = m1prior$b_alpha_dose_adj,\n                   m1_post = m1post$b_alpha_dose_adj,\n                   m3_prior = m3prior$b_alpha_dose_adj,\n                   m3_post =  m3post$b_alpha_dose_adj) %>%\n        pivot_longer(cols = everything(), names_to = c(\"model\",\"type\"), names_pattern = \"(.*)_(.*)\", values_to = \"value\")\n# make plot\np1 <- a1df %>%\n  ggplot() +\n  geom_density(aes(x = value, color = model, linetype = type), size = 1) +\n  theme_minimal()\nplot(p1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_1_3_prior_plots-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#save for display on post\nggsave(file = paste0(\"featured.png\"), p1, dpi = 300, units = \"in\", width = 6, height = 6)\n\n\n#showing density plots for b1\nb1df <- data.frame(m1_prior = m1prior$b_beta_dose_adj,\n                   m1_post = m1post$b_beta_dose_adj,\n                   m3_prior = m3prior$b_beta_dose_adj,\n                   m3_post =  m3post$b_beta_dose_adj) %>%\n  pivot_longer(cols = everything(), names_to = c(\"model\",\"type\"), names_pattern = \"(.*)_(.*)\", values_to = \"value\")\n\np2 <- b1df %>%\n  ggplot() +\n  geom_density(aes(x = value, color = model, linetype = type), size = 1) +\n  theme_minimal()\nplot(p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_1_3_prior_plots-2.png){width=672}\n:::\n:::\n\n\n\nAs before, the priors for the $a_1$ and $b_1$ parameters are the same. We only changed the $a_0$ and $b_0$ priors, but that change leads to different posteriors for $a_1$ and $b_1$. It's basically the same result we found with `ulam/rethinking`.\n\nIt would be surprising if we did NOT find the same correlation structure again in the parameters, let's check it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a few parameters for each dose\n#low dose\npairs(fit1, variable = variables(fit1)[c(1:4,25)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_1_3_pair_plots-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#medium dose\npairs(fit1, variable = variables(fit1)[c(8:11,25)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_1_3_pair_plots-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#high dose\npairs(fit1, variable = variables(fit1)[c(16:19,25)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_1_3_pair_plots-3.png){width=672}\n:::\n:::\n\n\n\nApart from the unfortunate naming of parameters in `brms`, these are the same plots as we made for the `ulam` fits and show the same patterns.\n\n\nLet's look at the posteriors in numerical form.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# model 1 first\nfit1pars = posterior::summarize_draws(m1post, \"mean\", \"sd\", \"quantile2\", default_convergence_measures())\n\n#only entries for the a0 parameters\na0post <- m1post %>% dplyr::select(starts_with('b_alpha_id'))\nfit1a0mean <- mean(colMeans(a0post))\n#only entries for the b0 parameters\nb0post <- m1post %>% dplyr::select(starts_with('b_beta_id'))\nfit1b0mean <- mean(colMeans(b0post))\nfit1otherpars <- fit1pars %>% dplyr::filter(!grepl('_id',variable)) %>%\n  dplyr::filter(!grepl('prior',variable))\nprint(fit1otherpars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 8\n  variable             mean     sd       q5     q95  rhat ess_bulk ess_tail\n  <chr>               <dbl>  <dbl>    <dbl>   <dbl> <dbl>    <dbl>    <dbl>\n1 b_alpha_dose_adj    0.224 0.726    -0.972    1.44  1.00    2839.    4785.\n2 b_beta_dose_adj    -0.212 0.744    -1.44     1.01  1.00    2419.    4163.\n3 sigma               1.06  0.0514    0.981    1.15  1.00   16342.   11307.\n4 lp__             -549.    5.58   -559.    -540.    1.00    4974.    8286.\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(c(fit1a0mean,fit1b0mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.960140 1.006334\n```\n\n\n:::\n\n```{.r .cell-code}\n# repeat for model 3\nfit3pars = posterior::summarize_draws(m3post, \"mean\", \"sd\", \"quantile2\", default_convergence_measures())\n#only entries for the a0 parameters\na0post <- m3post %>% dplyr::select(starts_with('b_alpha_id'))\nfit3a0mean <- mean(colMeans(a0post))\n#only entries for the b0 parameters\nb0post <- m3post %>% dplyr::select(starts_with('b_beta_id'))\nfit3b0mean <- mean(colMeans(b0post))\nfit3otherpars <- fit3pars %>% dplyr::filter(!grepl('_id',variable)) %>%\n  dplyr::filter(!grepl('prior',variable))\nprint(fit3otherpars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 8\n  variable              mean     sd        q5       q95  rhat ess_bulk ess_tail\n  <chr>                <dbl>  <dbl>     <dbl>     <dbl> <dbl>    <dbl>    <dbl>\n1 b_alpha_dose_adj    0.142  0.107    -0.0334    0.316   1.00    2426.    4307.\n2 b_beta_dose_adj    -0.0811 0.106    -0.254     0.0921  1.00    2939.    5258.\n3 sigma               1.06   0.0515    0.982     1.15    1.00   15960.   10880.\n4 lp__             -453.     5.60   -463.     -444.      1.00    4605.    7829.\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(c(fit3a0mean,fit3b0mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.9756367 0.9808696\n```\n\n\n:::\n:::\n\n\n\nAgain, model 1 seems worse, with higher uncertainty intervals for the $a_1$ and $b_1$ parameters and the mean further away from the true value. \n\nWe can also compare the models as we did for `rethinking` using these lines of code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit13comp <- loo_compare(add_criterion(fit1,\"waic\"),\n            add_criterion(fit3,\"waic\"),\n            criterion = \"waic\")\nprint(fit13comp, simplify = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                            elpd_diff se_diff elpd_waic se_elpd_waic p_waic\nadd_criterion(fit1, \"waic\")    0.0       0.0  -416.3      11.7         43.5\nadd_criterion(fit3, \"waic\")    0.0       0.2  -416.3      11.7         43.5\n                            se_p_waic waic   se_waic\nadd_criterion(fit1, \"waic\")    4.3     832.5   23.4 \nadd_criterion(fit3, \"waic\")    4.3     832.6   23.4 \n```\n\n\n:::\n:::\n\n\n\nModel performance is similar between models. The WAIC values are also close to those reported by `rethinking`. \n\n\n## Comparison with the truth and `ulam`\n\nThe values used to generate the data are: $\\sigma =$ 1, $\\mu_a =$ 3, $\\mu_b =$ 1, $a_1 =$ 0.1, $b_1 =$ -0.1. \n\nSince the models are the same as those we previously fit with `ulam`, only a different `R` package is used to run them, we should expect very similar results. This is the case. We find that as for the `ulam` fits, the estimates for $a_0$, $b_0$ and $\\sigma$ are similar to the values used the generate the data, but estimates for $a_1$ and $b_1$ are not that great. The agreement with `ulam` is good, because we should expect that if we fit the same models, results should - up to numerical/sampling differences - be the same, no matter what software implementation we use. It also suggests that we did things right - or made the same mistake in both implementations! ðŸ˜.\n\nWhy the WAIC estimates are different is currently not clear to me. It could be that the 2 packages use different definitions/ways to compute it. Or something more fundamental is still different. I'm not sure.\n\n\n\n\n## Model 2a\n\nThis is the model with only population-level estimates. We already explored it somewhat above when we looked at traceplots and trankplots and the like. \nHere is just another quick table for the posteriors.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2post <- as_draws_df(fit2)\nfit2pars = posterior::summarize_draws(m2post, \"mean\", \"sd\", \"quantile2\", default_convergence_measures())\nfit2otherpars <- fit2pars %>% dplyr::filter(!grepl('prior',variable))\nprint(fit2otherpars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 8\n  variable               mean      sd        q5      q95  rhat ess_bulk ess_tail\n  <chr>                 <dbl>   <dbl>     <dbl>    <dbl> <dbl>    <dbl>    <dbl>\n1 b_alpha_Intercept    2.98   0.0211     2.95    3.02e+0  1.00    6244.    6691.\n2 b_alpha_dose_adj     0.0960 0.00967    0.0802  1.12e-1  1.00    6569.    7301.\n3 b_beta_Intercept     0.992  0.0188     0.961   1.02e+0  1.00    6386.    6724.\n4 b_beta_dose_adj     -0.0971 0.00862   -0.111  -8.29e-2  1.00    6947.    7786.\n5 sigma                6.88   0.302      6.39    7.39e+0  1.00    8390.    7850.\n6 lp__              -892.     1.59    -895.     -8.90e+2  1.00    4964.    7039.\n```\n\n\n:::\n:::\n\n\n\nThe parameters that have `_Intercept` in their name are what we called $\\mu_a$ and $\\mu_b$, the ones containing `_dose` are our $a_1$ and $b_1$. We find pretty much the same results we found using `ulam`. Specifically, the main parameters are estimated well, but because the model is not very flexible, the estimate for $\\sigma$ is much larger, since it needs to account for all the individual-level variation we ommitted from the model itself.\n\n\n## Model 4\n\nThis is what I consider the most interesting and conceptually best model. It performed best in the `ulam` fits. Let's see how it looks here. It is worth pointing out that this model ran much faster compared to models 1 and 3, it only took 10.5518333 minutes.\n\nWe'll start with the summary for the model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit4 <- fl[[4]]$fit\nm4prior <- prior_draws(fit4)\nm4post <- as_draws_df(fit4)\nsummary(fit4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: outcome ~ exp(alpha) * log(time) - exp(beta) * time \n         alpha ~ (1 | id) + dose_adj\n         beta ~ (1 | id) + dose_adj\n   Data: fitdat (Number of observations: 264) \n  Draws: 5 chains, each with iter = 9000; warmup = 6000; thin = 1;\n         total post-warmup draws = 15000\n\nMultilevel Hyperparameters:\n~id (Number of levels: 24) \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(alpha_Intercept)     0.09      0.02     0.07     0.13 1.00     3685     6514\nsd(beta_Intercept)      0.12      0.02     0.09     0.16 1.00     4048     5853\n\nRegression Coefficients:\n                Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nalpha_Intercept     2.99      0.02     2.95     3.03 1.00     3771     5404\nalpha_dose_adj      0.09      0.01     0.07     0.11 1.00     3979     5040\nbeta_Intercept      0.99      0.02     0.94     1.03 1.00     3486     5134\nbeta_dose_adj      -0.11      0.01    -0.13    -0.08 1.00     3855     5732\n\nFurther Distributional Parameters:\n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     1.06      0.05     0.97     1.17 1.00    10136    10314\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\n\nNext, the prior/posterior plots. To ensure one can see the priors, I'm cutting off the y-axis at 10, that's why the posteriors look a bit weird. They do infected extend and peak like the distributions shown for models 1 and 3.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#showing density plots for a1 and b1\n#make a data frame and get it in shape for ggplot\nm4df <- data.frame(a1_prior = m4prior$b_alpha_dose_adj,\n                   a1_post = m4post$b_alpha_dose_adj,\n                   b1_prior = m4prior$b_beta_dose_adj,\n                   b1_post = m4post$b_beta_dose_adj) %>%\n  pivot_longer(cols = everything(), names_to = c(\"parameter\",\"type\"), names_pattern = \"(.*)_(.*)\", values_to = \"value\")\n# make plot\np1 <- m4df %>%\n  ggplot() +\n  ylim(0, 10) + xlim(-2, 2) +\n  geom_density(aes(x = value, color = parameter, linetype = type), adjust = 10, size = 1) +\n  ggtitle('model 4, parameters a1 and b1') +\n  theme_minimal()\nplot(p1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_4_prior_plots-1.png){width=672}\n:::\n:::\n\n\n\nNumerical output for the posterior:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit4pars = posterior::summarize_draws(m4post, \"mean\", \"sd\", \"quantile2\", default_convergence_measures())\nfit4otherpars <- fit4pars %>% dplyr::filter(!grepl('_id',variable)) %>%\n  dplyr::filter(!grepl('prior',variable)) %>%\n  dplyr::filter(!grepl('z_',variable))\n\nprint(fit4otherpars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 8\n  variable               mean     sd        q5       q95  rhat ess_bulk ess_tail\n  <chr>                 <dbl>  <dbl>     <dbl>     <dbl> <dbl>    <dbl>    <dbl>\n1 b_alpha_Intercept    2.99   0.0197    2.95      3.02    1.00    3771.    5404.\n2 b_alpha_dose_adj     0.0861 0.0106    0.0688    0.104   1.00    3979.    5040.\n3 b_beta_Intercept     0.987  0.0247    0.946     1.03    1.00    3486.    5134.\n4 b_beta_dose_adj     -0.106  0.0131   -0.127    -0.0844  1.00    3855.    5732.\n5 sigma                1.06   0.0517    0.981     1.15    1.00   10135.   10314.\n6 lp__              -468.     7.47   -481.     -457.      1.00    2720.    4987.\n```\n\n\n:::\n:::\n\n\n\nThese estimates look good, close to the truth.\n\nFinishing with the pairs lots:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a few parameters for each dose\n#low dose\npairs(fit4, variable = variables(fit4)[c(1:4,25)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_4_pair_plots-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#medium dose\npairs(fit4, variable = variables(fit4)[c(8:11,25)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_4_pair_plots-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#high dose\npairs(fit4, variable = variables(fit4)[c(16:19,25)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mod_4_pair_plots-3.png){width=672}\n:::\n:::\n\n\n\nThe strong correlations between parameters are reduced, the same we say with the `ulam` models.\n\nAs was the case for the `ulam` fits, model 4 seems to perform overall best.\n\n## Comparing all models\n\n\nWe can repeat the model comparison we did above, now including all 4 models. I'm looking now at both WAIC and LOO (leave one out). Note the various warning messages. We got that as well when we computed PSIS (which is similar to LOO) with `rethinking`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit1a <- add_criterion(fit1,c(\"waic\",\"loo\"))\nfit2a <- add_criterion(fit2,c(\"waic\",\"loo\"))\nfit3a <- add_criterion(fit3,c(\"waic\",\"loo\"))\nfit4a <- add_criterion(fit4,c(\"waic\",\"loo\"))\ncompall1 <- loo_compare(fit1a,fit2a,fit3a,fit4a, criterion = \"waic\")\ncompall2 <- loo_compare(fit1a,fit2a,fit3a,fit4a, criterion = \"loo\")\nprint(compall1, simplify = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      elpd_diff se_diff elpd_waic se_elpd_waic p_waic se_p_waic waic   se_waic\nfit4a    0.0       0.0  -415.7      11.7         42.7    4.3     831.4   23.4 \nfit1a   -0.6       1.2  -416.3      11.7         43.5    4.3     832.5   23.4 \nfit3a   -0.6       1.3  -416.3      11.7         43.5    4.3     832.6   23.4 \nfit2a -473.6      23.0  -889.4      22.4         10.3    3.0    1778.7   44.8 \n```\n\n\n:::\n\n```{.r .cell-code}\nprint(compall2, simplify = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      elpd_diff se_diff elpd_loo se_elpd_loo p_loo  se_p_loo looic  se_looic\nfit4a    0.0       0.0  -419.8     12.1        46.8    5.0    839.6   24.2  \nfit3a   -0.6       1.4  -420.4     12.1        47.6    5.0    840.7   24.2  \nfit1a   -1.1       1.5  -421.0     12.2        48.2    5.1    841.9   24.4  \nfit2a -469.6      23.0  -889.4     22.4        10.3    3.1   1778.9   44.8  \n```\n\n\n:::\n:::\n\n\n\nModel 4 is considered best, though not by much. The above results, namely faster runtime and better estimates, speak more convincingly to the fact that model 4 is the best of these. The LOO is close to the PSIS metric reported by `rethinking`, even though I don't think it's defined and computed exactly the same. \n\n\n\n## Prior exploration\n\nSince `brms` has a way of specifying the model and priors that makes direct mapping to the mathematical model a bit more opaque, it is useful to explore if the models we run are what we think we run. `brms` has two helpful functions for looking at priors. One can help set priors before fitting, the other shows priors after fitting. \nTo make the output manageable, we look at the simplest model, model 2. This looks as follows\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#defining model again\nm2aeqs <- bf(outcome ~ exp(alpha)*log(time) - exp(beta)*time,\n  alpha ~ 1 + dose_adj,\n  beta  ~  1 + dose_adj,\n  nl = TRUE)\npreprior2 <- get_prior(m2aeqs,data=fitdat,family=gaussian())\npostprior2 <- prior_summary(fit2)\nprint(preprior2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               prior class      coef group resp dpar nlpar lb ub       source\n student_t(3, 0, 23) sigma                                  0         default\n              (flat)     b                           alpha            default\n              (flat)     b  dose_adj                 alpha       (vectorized)\n              (flat)     b Intercept                 alpha       (vectorized)\n              (flat)     b                            beta            default\n              (flat)     b  dose_adj                  beta       (vectorized)\n              (flat)     b Intercept                  beta       (vectorized)\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(postprior2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           prior class      coef group resp dpar nlpar lb ub  source\n          (flat)     b                           alpha       default\n  normal(0.3, 1)     b  dose_adj                 alpha          user\n    normal(2, 2)     b Intercept                 alpha          user\n          (flat)     b                            beta       default\n normal(-0.3, 1)     b  dose_adj                  beta          user\n  normal(0.5, 2)     b Intercept                  beta          user\n    cauchy(0, 1) sigma                                  0       user\n```\n\n\n:::\n:::\n\n\n\nThe first output shows the priors as the model sees them, before we apply any settings. It uses defaults. The second output shows the actual priors used when fitting the model, which are the ones we set. I find these functions and the information useful, but overall it's still a bit confusing to me. For instance why are there those `flat` entries in there? I don't know what they mean.\n\nIt gets worse for bigger models, and here things get confusing to me. This is looking at the priors for models 1,3 and 4. Recall that we expect $2(N+1)+1$ priors for models 1 and 3, and $2(N+1+1)+1$ for model 4. Since our data has 24 samples, we should find 51 and 53 priors. \nHere is what we get:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npostprior1 <- prior_summary(fit1)\npostprior3 <- prior_summary(fit3)\npostprior4 <- prior_summary(fit4)\nprint(paste(nrow(postprior1),nrow(postprior3),nrow(postprior4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"53 53 13\"\n```\n\n\n:::\n:::\n\n\n\nCloser inspection shows that for models 1 and 3, the priors include those strange `flat` ones that only have a class but no coefficient. My guess is those are not \"real\", and thus we actually have the right number of priors/parameters. This can be checked by looking at the names of all the parameters for say model 1. Here they are:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(m1post)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] \"b_alpha_id1\"            \"b_alpha_id2\"            \"b_alpha_id3\"           \n  [4] \"b_alpha_id4\"            \"b_alpha_id5\"            \"b_alpha_id6\"           \n  [7] \"b_alpha_id7\"            \"b_alpha_id8\"            \"b_alpha_id9\"           \n [10] \"b_alpha_id10\"           \"b_alpha_id11\"           \"b_alpha_id12\"          \n [13] \"b_alpha_id13\"           \"b_alpha_id14\"           \"b_alpha_id15\"          \n [16] \"b_alpha_id16\"           \"b_alpha_id17\"           \"b_alpha_id18\"          \n [19] \"b_alpha_id19\"           \"b_alpha_id20\"           \"b_alpha_id21\"          \n [22] \"b_alpha_id22\"           \"b_alpha_id23\"           \"b_alpha_id24\"          \n [25] \"b_alpha_dose_adj\"       \"b_beta_id1\"             \"b_beta_id2\"            \n [28] \"b_beta_id3\"             \"b_beta_id4\"             \"b_beta_id5\"            \n [31] \"b_beta_id6\"             \"b_beta_id7\"             \"b_beta_id8\"            \n [34] \"b_beta_id9\"             \"b_beta_id10\"            \"b_beta_id11\"           \n [37] \"b_beta_id12\"            \"b_beta_id13\"            \"b_beta_id14\"           \n [40] \"b_beta_id15\"            \"b_beta_id16\"            \"b_beta_id17\"           \n [43] \"b_beta_id18\"            \"b_beta_id19\"            \"b_beta_id20\"           \n [46] \"b_beta_id21\"            \"b_beta_id22\"            \"b_beta_id23\"           \n [49] \"b_beta_id24\"            \"b_beta_dose_adj\"        \"sigma\"                 \n [52] \"prior_b_alpha_id1\"      \"prior_b_alpha_id2\"      \"prior_b_alpha_id3\"     \n [55] \"prior_b_alpha_id4\"      \"prior_b_alpha_id5\"      \"prior_b_alpha_id6\"     \n [58] \"prior_b_alpha_id7\"      \"prior_b_alpha_id8\"      \"prior_b_alpha_id9\"     \n [61] \"prior_b_alpha_id10\"     \"prior_b_alpha_id11\"     \"prior_b_alpha_id12\"    \n [64] \"prior_b_alpha_id13\"     \"prior_b_alpha_id14\"     \"prior_b_alpha_id15\"    \n [67] \"prior_b_alpha_id16\"     \"prior_b_alpha_id17\"     \"prior_b_alpha_id18\"    \n [70] \"prior_b_alpha_id19\"     \"prior_b_alpha_id20\"     \"prior_b_alpha_id21\"    \n [73] \"prior_b_alpha_id22\"     \"prior_b_alpha_id23\"     \"prior_b_alpha_id24\"    \n [76] \"prior_b_alpha_dose_adj\" \"prior_b_beta_id1\"       \"prior_b_beta_id2\"      \n [79] \"prior_b_beta_id3\"       \"prior_b_beta_id4\"       \"prior_b_beta_id5\"      \n [82] \"prior_b_beta_id6\"       \"prior_b_beta_id7\"       \"prior_b_beta_id8\"      \n [85] \"prior_b_beta_id9\"       \"prior_b_beta_id10\"      \"prior_b_beta_id11\"     \n [88] \"prior_b_beta_id12\"      \"prior_b_beta_id13\"      \"prior_b_beta_id14\"     \n [91] \"prior_b_beta_id15\"      \"prior_b_beta_id16\"      \"prior_b_beta_id17\"     \n [94] \"prior_b_beta_id18\"      \"prior_b_beta_id19\"      \"prior_b_beta_id20\"     \n [97] \"prior_b_beta_id21\"      \"prior_b_beta_id22\"      \"prior_b_beta_id23\"     \n[100] \"prior_b_beta_id24\"      \"prior_b_beta_dose_adj\"  \"prior_sigma\"           \n[103] \"lprior\"                 \"lp__\"                   \".chain\"                \n[106] \".iteration\"             \".draw\"                 \n```\n\n\n:::\n:::\n\n\n\nWe can see that there are the right number of both priors and posterior parameters, namely 2 times 24 for the individual level parameters, plus 2 dose parameters and $\\sigma$. \n\nI find model 4 more confusing. Here is the full list of priors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(postprior4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           prior class      coef group resp dpar nlpar lb ub       source\n          (flat)     b                           alpha            default\n  normal(0.3, 1)     b  dose_adj                 alpha               user\n    normal(2, 1)     b Intercept                 alpha               user\n          (flat)     b                            beta            default\n normal(-0.3, 1)     b  dose_adj                  beta               user\n  normal(0.5, 1)     b Intercept                  beta               user\n    cauchy(0, 1)    sd                           alpha  0            user\n    cauchy(0, 1)    sd                            beta  0            user\n    cauchy(0, 1)    sd              id           alpha  0    (vectorized)\n    cauchy(0, 1)    sd Intercept    id           alpha  0    (vectorized)\n    cauchy(0, 1)    sd              id            beta  0    (vectorized)\n    cauchy(0, 1)    sd Intercept    id            beta  0    (vectorized)\n    cauchy(0, 1) sigma                                  0            user\n```\n\n\n:::\n:::\n\n\n\nAnd this shows the names of all parameters \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(m4post)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] \"b_alpha_Intercept\"         \"b_alpha_dose_adj\"         \n  [3] \"b_beta_Intercept\"          \"b_beta_dose_adj\"          \n  [5] \"sd_id__alpha_Intercept\"    \"sd_id__beta_Intercept\"    \n  [7] \"sigma\"                     \"r_id__alpha[1,Intercept]\" \n  [9] \"r_id__alpha[2,Intercept]\"  \"r_id__alpha[3,Intercept]\" \n [11] \"r_id__alpha[4,Intercept]\"  \"r_id__alpha[5,Intercept]\" \n [13] \"r_id__alpha[6,Intercept]\"  \"r_id__alpha[7,Intercept]\" \n [15] \"r_id__alpha[8,Intercept]\"  \"r_id__alpha[9,Intercept]\" \n [17] \"r_id__alpha[10,Intercept]\" \"r_id__alpha[11,Intercept]\"\n [19] \"r_id__alpha[12,Intercept]\" \"r_id__alpha[13,Intercept]\"\n [21] \"r_id__alpha[14,Intercept]\" \"r_id__alpha[15,Intercept]\"\n [23] \"r_id__alpha[16,Intercept]\" \"r_id__alpha[17,Intercept]\"\n [25] \"r_id__alpha[18,Intercept]\" \"r_id__alpha[19,Intercept]\"\n [27] \"r_id__alpha[20,Intercept]\" \"r_id__alpha[21,Intercept]\"\n [29] \"r_id__alpha[22,Intercept]\" \"r_id__alpha[23,Intercept]\"\n [31] \"r_id__alpha[24,Intercept]\" \"r_id__beta[1,Intercept]\"  \n [33] \"r_id__beta[2,Intercept]\"   \"r_id__beta[3,Intercept]\"  \n [35] \"r_id__beta[4,Intercept]\"   \"r_id__beta[5,Intercept]\"  \n [37] \"r_id__beta[6,Intercept]\"   \"r_id__beta[7,Intercept]\"  \n [39] \"r_id__beta[8,Intercept]\"   \"r_id__beta[9,Intercept]\"  \n [41] \"r_id__beta[10,Intercept]\"  \"r_id__beta[11,Intercept]\" \n [43] \"r_id__beta[12,Intercept]\"  \"r_id__beta[13,Intercept]\" \n [45] \"r_id__beta[14,Intercept]\"  \"r_id__beta[15,Intercept]\" \n [47] \"r_id__beta[16,Intercept]\"  \"r_id__beta[17,Intercept]\" \n [49] \"r_id__beta[18,Intercept]\"  \"r_id__beta[19,Intercept]\" \n [51] \"r_id__beta[20,Intercept]\"  \"r_id__beta[21,Intercept]\" \n [53] \"r_id__beta[22,Intercept]\"  \"r_id__beta[23,Intercept]\" \n [55] \"r_id__beta[24,Intercept]\"  \"prior_b_alpha_Intercept\"  \n [57] \"prior_b_alpha_dose_adj\"    \"prior_b_beta_Intercept\"   \n [59] \"prior_b_beta_dose_adj\"     \"prior_sigma\"              \n [61] \"prior_sd_id\"               \"prior_sd_id__1\"           \n [63] \"lprior\"                    \"lp__\"                     \n [65] \"z_1[1,1]\"                  \"z_1[1,2]\"                 \n [67] \"z_1[1,3]\"                  \"z_1[1,4]\"                 \n [69] \"z_1[1,5]\"                  \"z_1[1,6]\"                 \n [71] \"z_1[1,7]\"                  \"z_1[1,8]\"                 \n [73] \"z_1[1,9]\"                  \"z_1[1,10]\"                \n [75] \"z_1[1,11]\"                 \"z_1[1,12]\"                \n [77] \"z_1[1,13]\"                 \"z_1[1,14]\"                \n [79] \"z_1[1,15]\"                 \"z_1[1,16]\"                \n [81] \"z_1[1,17]\"                 \"z_1[1,18]\"                \n [83] \"z_1[1,19]\"                 \"z_1[1,20]\"                \n [85] \"z_1[1,21]\"                 \"z_1[1,22]\"                \n [87] \"z_1[1,23]\"                 \"z_1[1,24]\"                \n [89] \"z_2[1,1]\"                  \"z_2[1,2]\"                 \n [91] \"z_2[1,3]\"                  \"z_2[1,4]\"                 \n [93] \"z_2[1,5]\"                  \"z_2[1,6]\"                 \n [95] \"z_2[1,7]\"                  \"z_2[1,8]\"                 \n [97] \"z_2[1,9]\"                  \"z_2[1,10]\"                \n [99] \"z_2[1,11]\"                 \"z_2[1,12]\"                \n[101] \"z_2[1,13]\"                 \"z_2[1,14]\"                \n[103] \"z_2[1,15]\"                 \"z_2[1,16]\"                \n[105] \"z_2[1,17]\"                 \"z_2[1,18]\"                \n[107] \"z_2[1,19]\"                 \"z_2[1,20]\"                \n[109] \"z_2[1,21]\"                 \"z_2[1,22]\"                \n[111] \"z_2[1,23]\"                 \"z_2[1,24]\"                \n[113] \".chain\"                    \".iteration\"               \n[115] \".draw\"                    \n```\n\n\n:::\n:::\n\n\n\nTo compare directly, this is the model we want:\n\n$$\n\\begin{aligned}\nY_{i,t}  & \\sim \\mathrm{Normal}\\left(\\mu_{i,t}, \\sigma\\right) \\\\\n\\mu_{i,t} &  =  \\exp(\\alpha_{i}) \\log (t_{i}) -\\exp(\\beta_{i}) t_{i} \\\\\n\\alpha_{i} &  =  a_{0,i} + a_1 \\left(\\log (D_i) - \\log (D_m)\\right)  \\\\\n\\beta_{i} &  =  b_{0,i} + b_1 \\left(\\log (D_i) - \\log (D_m)\\right) \\\\\na_{0,i} & \\sim \\mathrm{Normal}(\\mu_a, \\sigma_a) \\\\\nb_{0,i} & \\sim \\mathrm{Normal}(\\mu_b, \\sigma_a) \\\\\na_1 & \\sim \\mathrm{Normal}(0.3, 1) \\\\\nb_1 & \\sim \\mathrm{Normal}(-0.3, 1) \\\\\n\\mu_a & \\sim \\mathrm{Normal}(2, 1) \\\\\n\\mu_b & \\sim \\mathrm{Normal}(0.5, 1) \\\\\n\\sigma &  \\sim \\mathrm{HalfCauchy}(0,1)  \\\\\n\\sigma_a & \\sim \\mathrm{HalfCauchy}(0,1)  \\\\\n\\sigma_b & \\sim \\mathrm{HalfCauchy}(0,1)  \n\\end{aligned}\n$$\n\nIf understand `brms` correctly, those `z_` parameters are internal adjustments to make things more efficient and can otherwise be ignored. That means we have 2 times 24 parameters for the individual levels that all start with `r_id`. Those correspond to the $a_{0,i}$ and $b_{0,1}$, and they don't have pre-defined priors, since they are computed based on other parameters. Then we have 2 dose parameters, which map to $a_1$ and $b_1$, both come with priors. We have 2 `_Intercept` parameters, which correspond to $\\mu_a$ and $\\mu_b$, again with priors. We have $\\sigma$ with prior, and the two `sd_id` parameters seem to be those we call $\\sigma_a$ and $\\sigma_b$ in our equations. \n\nSo it looks like there is a match between our mathematical model we want, and the way we implemented it in `brms`. Still, I find the `brms` notation confusing and not that easy to follow. In that respect I much prefer `ulam/rethinking`.\n\nIn any case, I somewhat convinced myself that I'm fitting the same models here with `brms` that I'm fitting with `ulam`.\n\n\n# Computing predictions\n\nLooking at tables of estimates as we did so far is somewhat useful, but nothing can beat graphical inspection. So let's plot the predictions implied by the fits for the models. The general strategy for that is to use the parameter estimates in the posterior, put them in the model, and compute the predictions. \nWhile the `rethinking` package had `sim` and `link`, for `brms` those functions are `fitted` and `predict`. \n\nThe code below produces predictions, both for the deterministic mean trajectory $\\mu$, and the actual outcome, $Y$, which has added variation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#this will contain all the predictions from the different models\nfitpred = vector(mode = \"list\", length = length(fl))\n\n# load the data we used for fitting\nsimdat <- readRDS(\"simdat.Rds\")\n#pull our the data set we used for fitting\n#if you fit a different one of the simulated datasets, change accordingly\nfitdat <- simdat$m3\n#small data adjustment for plotting\nplotdat <- fitdat %>% data.frame() %>% mutate(id = as.factor(id)) %>% mutate(dose = dose_cat)\n\n\n# we are looping over each fitted model\nfor (n in 1:length(fl))\n{\n  #get current model\n  nowmodel = fl[[n]]$fit\n\n  #make new data for which we want predictions\n  #specifically, more time points so the curves are smoother\n  timevec = seq(from = 0.1, to = max(fitdat$time), length=100)\n  Ntot = max(fitdat$id)\n  #data used for predictions\n  preddat = data.frame( id = sort(rep(seq(1,Ntot),length(timevec))),\n                        time = rep(timevec,Ntot),\n                        dose_adj = 0\n  )\n  #add right dose information for each individual\n  for (k in 1:Ntot)\n  {\n    #dose for a given individual\n    nowdose = unique(fitdat$dose_adj[fitdat$id == k])\n    nowdose_cat = unique(fitdat$dose_cat[fitdat$id == k])\n    #assign that dose\n    #the categorical values are just for plotting\n    preddat[(preddat$id == k),\"dose_adj\"] = nowdose\n    preddat[(preddat$id == k),\"dose_cat\"] = nowdose_cat\n  }\n\n  # estimate and CI for parameter variation\n  #brms equivalent to rethinking::link\n  #doing 89% CI\n  meanpred <- fitted(nowmodel, newdata = preddat, probs = c(0.055, 0.945) )\n\n  # estimate and CI for prediction intervals\n  # the predictions factor in additional uncertainty around the mean (mu)\n  # as indicated by sigma\n  # this is equivalent to rethinking::sim()\n  outpred <- predict(nowmodel, newdata = preddat, probs = c(0.055, 0.945) )\n\n\n  #place all predictions into a data frame\n  #and store in a list for each model\n  fitpred[[n]] = data.frame(id = as.factor(preddat$id),\n                            dose = as.factor(preddat$dose_cat),\n                            predtime = preddat$time,\n                            Estimate = meanpred[,\"Estimate\"],\n                            Q89lo = meanpred[,\"Q5.5\"],\n                            Q89hi = meanpred[,\"Q94.5\"],\n                            Qsimlo = outpred[,\"Q5.5\"],\n                            Qsimhi = outpred[,\"Q94.5\"]\n  )\n}\n\n\n#########################\n# generate plots showing data and model predictions\n#########################\n```\n:::\n\n\n\n\n# Creating plots of the results\n\nNow that we got the predictions computed, we can plot them and compare with the data.\nI'm showing the same uncertainty intervals I used for `rethinking` to make comparison easy.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#storing all plots\nplotlist = vector(mode = \"list\", length = length(fl))\n\n#adding titles to plots\ntitles = c('model 1','model 2a','model 3','model 4')\n\n#again looping over all models, making a plot for each\nfor (n in 1:length(fl))\n{\n  # ===============================================\n  plotlist[[n]] <- ggplot(data = fitpred[[n]], aes(x = predtime, y = Estimate, group = id, color = dose ) ) +\n    geom_line() +\n    geom_ribbon(aes(x=predtime, ymin=Q89lo, ymax=Q89hi, fill = dose, color = NULL), alpha=0.3, show.legend = F) +\n    geom_ribbon(aes(x=predtime, ymin=Qsimlo, ymax=Qsimhi, fill = dose, color = NULL), alpha=0.1, show.legend = F) +\n    geom_point(data = plotdat, aes(x = time, y = outcome, group = id, color = dose), shape = 1, size = 2) +\n    scale_y_continuous(limits = c(-30,50)) +\n    labs(y = \"Virus load\",\n         x = \"days post infection\") +\n    theme_minimal() +\n    ggtitle(titles[n])\n  ggsave(file = paste0(titles[n],\".png\"), plotlist[[n]], dpi = 300, units = \"in\", width = 7, height = 7)\n}\n\n\n\n#########################\n# show the plots\n#########################\n```\n:::\n\n\n\n\n# Showing the plots \n\nHere are the plots for all models we considered.\n\nIt's a bit hard to see, but each plot contains for each individual the data as symbols, the estimated mean as line, and the 89% credible interval and prediction interval as shaded areas.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(plotlist[[1]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/showplots-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(plotlist[[3]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/showplots-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(plotlist[[2]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/showplots-3.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(plotlist[[4]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/showplots-4.png){width=672}\n:::\n:::\n\n\n\n\nMirroring the findings from above, the models produce very similar results, especially models 1,3 and 4. Model 2a shows the feature of having very wide prediction intervals, due to the fact that it can't account for individual-level variation in the main model.\n\n\n\n# Summary and continuation\n\nTo sum it up, we repeated our previous fitting, now using the `brms` package instead of `rethinking`. While the two packages have different syntax, the models we fit are the same and thus the results are very close too. That's comforting. If one approach had produced very different results, it would have meant something was wrong. Of course, as I was writing this series of posts, that happened many times and it took me a while to figure out how to get `brms` to do what I wanted it to ðŸ˜.\n\nAs of this writing, the one issue I'm almost but not yet fully certain about is if I really have a full match between my mathematical models and the `brms` implementations (I'm fairly certain the math and `ulam` implementations match). Though the comparison between `ulam` and `brms` results do suggest that I'm running the same models.\n\nOverall, I like the approach of using both packages. It adds an extra layer of robustness. The `rethinking` code is very close to the math and thus quickly implemented and probably a good first step. `brms` has some features that go beyond what `rethinking` can (easily) do, so moving on to re-implementing models in `brms` and using that code for producing the final results can make sense.\n\nThis ends the main part of the tutorial (for now). There were several topics I wanted to discuss that didn't fit here. If you are interested in some further musings, you can hop to [this post](/posts/longitudinal-multilevel-bayesian-analysis-4/), where I discuss a few further topics and variations. \n\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}